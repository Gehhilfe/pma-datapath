% !TeX spellcheck = en_US
\documentclass[a4paper]{scrartcl}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{tikz}

\usetikzlibrary{shapes, arrows, positioning}

\tikzstyle{block} = [draw, rectangle]

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ 
	backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
	basicstyle=\tiny,        % the size of the fonts that are used for the code
	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
	breaklines=true,                 % sets automatic line breaking
	captionpos=b,                    % sets the caption-position to bottom
	commentstyle=\color{mygreen},    % comment style
	deletekeywords={...},            % if you want to delete keywords from the given language
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
	frame=single,	                   % adds a frame around the code
	keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
	keywordstyle=\color{blue},       % keyword style
	language=Octave,                 % the language of the code
	morekeywords={*,...},            % if you want to add more keywords to the set
	numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
	numbersep=5pt,                   % how far the line-numbers are from the code
	numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
	rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false,          % underline spaces within strings only
	showtabs=false,                  % show tabs within strings adding particular underscores
	stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
	stringstyle=\color{mymauve},     % string literal style
	tabsize=2,	                   % sets default tabsize to 2 spaces
	title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\begin{document}
	
	\title{Processor Microarchitecture Exercise Report}
	\author{Tim Burkert}
	
	\maketitle
	
	\begin{abstract}
		Report, results and evaluation of practical exercises done during processor microarchitecture lecture.
	\end{abstract}
	
	\section{Exercise Description}
	As a practial exercise three different testcases are given. For each testcase four assignments need to be fulfilled.
	
	\paragraph{Testcases}
	
	\begin{description}
		\item Color conversion \\
		RGB color to grayscale with following equation: \\
		$\textbf{intensity} = 0.29894*r + 0.58704*g + 0.11402*b$
		
		\item Histogram calculation \\
		Create a histogram with a given amount of bins for a set of values \\
		$\textbf{histogram[intensity(x,y)]} += 1, \forall (x,y) \in Image$
		
		\item Edge detection \\
		Applying sobel filter to an image \\
		$E(x,y) = I(x,y) * S(x,y)$
	\end{description}
	
	\paragraph{Assigments}
	
	\begin{description}
		\item Write the the program \\
		Experiment in octave \\
		Convert from octave to c \\
		
		\item Analyze classical in-order execution \\
		Compile C to SpartanMC and LEON3 assembly \\
		Analyze the used instructions from the assembly listing a statistics \\
		Profile the execution in ModelSim a statistics \\
		Based on the previous analyses suggest instruction set improvements \\
		
		\item Datapath construction \\
		Construct a statically scheduled pipeline for the computation in C \\
		Get the basic function units from Xilinx Coregen \\
		Verify the datapath in ModelSim against the reference data from C\\
		
		\item Analyze micro-threaded in-order execution \\
		Convert the C program to the SLC language or by hand to the microthreaded assembly. \\
		Execute in UTLEON3 â€“ ModelSim, SP605 \\
		Profile execution in ModelSim, identify bottlenecks and restructure the program accordingly \\
	\end{description}
	
	\section{Color Conversion}
	Conversion form a 24 Bit rgb value to an 8 Bit grayscale value can be done with various precisions and methods. A example using double precision floats is given in octave \textit{rgb2gray}. This method uses a luminosity equation to compute the intensity for each pixel. We implemented the same equation using fixed point arithmetics. For this we firstly converted the luminosities factors for each color to 20 Bit integer value.
	\begin{align*}
		rf &= 0.29894_{10} \approx  0.01001100100001110101_{2} = 313461_{10} * 2^{-20} \\
		gf &= 0.58704_{10} \approx  0.10010110010010000100_{2} = 615556_{10} * 2^{-20} \\
		bf &= 0.11402_{10} \approx  0.00011101001100000111_{2} = 119559_{10} * 2^{-20} \\
	\end{align*}
	
	To test how different precisions for each factor perform we implemented a following octave function. The function takes an image and a 3x1 vector describing the bit precision for each factor from max 20 to 0. With this function we can test arbitrary bit length combinations.

\begin{minipage}{\linewidth}
\begin{lstlisting}
function [J] = ui8rgb2gray (I, bits)
rf = bitshift(uint64(313461), bits(1)-20);  # 0.01001100100001110101
gf = bitshift(uint64(615556), bits(2)-20);  # 0.10010110010010000100
bf = bitshift(uint64(119559), bits(3)-20);  # 0.00011101001100000111
uI = uint64(I);
for i = 1:rows(I)
	for j = 1:columns(I)
		r = rf * uI(i,j,1);
		g = gf * uI(i,j,2);
		b = bf * uI(i,j,3);
		J(i,j) = uint8(bitshift(r, -bits(1))) 
			+ uint8(bitshift(g, -bits(2))) 
			+ uint8(bitshift(b, -bits(3)));
	endfor
endfor
endfunction
\end{lstlisting}
\end{minipage}	

    \subsection{Error Evaluation}

	The total error of rgb to grayscale conversion is a combination of the independent transformation for each channel. The total worst case error is the sum of all three partial worst case errors. Therefore to decide how many bits precision are need for each color channel, we did an error evaluation of each channel. For this we used three different metrics: Maximum Difference, Maximum Weighted Difference and Root Mean Square Error (RMSE)

\paragraph{}
The Maximum Weighted Difference describes the error for a total converted image better then the other metrics. Because the total error of each channel does not effect the total error equal. The total error contribution is depends on the used conversion factors for each channel.
\begin{align*}
 \textbf{intensity} &= 0.29894*r + 0.58704*g + 0.11402*b
\end{align*}


Therefore the green channel twice the error contribution then the red channel and six times the contribution to the blue channel. Because this asymmetric error contribution we chose an asymmetric bit precision for each channel. We used for the green channel 7 Bit precision conversion factor, red channel 6 Bit precision conversion factor and for the blue channel only a 5 Bit precision conversion factor.

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{gray_error} 
  \caption{Maximum difference, weighted maximum difference and RMS Error comparing octave rgb2gray and our implementation.}
\end{figure}


\subsection{C Implementation}

For the C implementation we used a straight forward two dimensional for loop that applies our conversion for each pixel. The rgb2gray function uses the same algorithm as our octave implementation. For validation we exported an small 15x15 image with octave as a constant static input array and printing the resulting array with printf. Therefor we could compare the results for all execution targets. For dynamic code evaluation we used following bash command:

\begin{minipage}{\linewidth}
\begin{lstlisting}
grep -n "cpu0" perf-transcript | awk '{print $7}' | sort | uniq -c | sort -hr
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=C]
static inline uint8_t rgb2gray(const uint8_t *p) {
	const uint16_t Rc = 19; //0b0.010011
	const uint16_t Gc = 75; //0b0.1001011
	const uint16_t Bc = 3;  //0b0.00011
	uint8_t nR = (uint8_t)((Rc*p[0])>>6);
	uint8_t nG = (uint8_t)((Gc*p[1])>>7);
	uint8_t nB = (uint8_t)((Bc*p[2])>>5);
	uint8_t res = nR + nG + nB;
	return res;
}
\end{lstlisting}
\end{minipage}

The result of dynamic tracing is attach as a file. Each instruction not executed and therefore not needed can be dropped. This simplifies the processor pipeline, but also restricts the functionality. These kind of optimization are only feasible for a FPGA, because removed instructions can be added again. 

\subsection{Datapath}
The mayor problem for the datapath construction is that the assigned amount of adders and multipliers are limited and free running. The consuming side of each pipeline can stall the processing at any time. Therefore there is two solution to consumer stall problem.
\begin{itemize}
	\item Free running pipeline with a consecutive memory element that can store all remaining intermediate result.
	
	\item Abstract the free running operators with a restore after stall logic. E.g. during a stall feed values in a cycle.  
\end{itemize}

 \begin{figure}[h]
	\centering
	\begin{tikzpicture}[node distance=1cm, auto, >=latex']
		\node [] (inr) {$r$};
		\node [below= 2cm of inr] (cr) {$r_{faktor}$};
		\node [below= 3cm of inr] (ing) {$g$};
		\node [below= 2cm of ing] (cg) {$g_{faktor}$};
		\node [below= 3cm of ing] (inb) {$b$};
		\node [below= 2cm of inb] (cb) {$c_{faktor}$};
		\node [draw, circle, below right= of inr] (mulr) {$\times$};
		\node [draw, rectangle, right= 0cm of mulr, minimum height=0.6cm] (mulr1) {}; 
		\node [draw, rectangle, right= 0cm of mulr1, minimum height=0.6cm] (mulr2) {};
		\node [draw, rectangle, right= 0cm of mulr2, minimum height=0.6cm] (mulr3) {};
		\node [draw, rectangle, right= 0cm of mulr3, minimum height=0.6cm] (mulr4) {};
		\node [draw, circle, below right= of ing] (mulg) {$\times$}; 
		\node [draw, rectangle, right= 0cm of mulg, minimum height=0.6cm] (mulg1) {}; 
		\node [draw, rectangle, right= 0cm of mulg1, minimum height=0.6cm] (mulg2) {};
		\node [draw, rectangle, right= 0cm of mulg2, minimum height=0.6cm] (mulg3) {};
		\node [draw, rectangle, right= 0cm of mulg3, minimum height=0.6cm] (mulg4) {};
		\node [draw, circle, below right= of inb] (mulb) {$\times$}; 
		\node [draw, rectangle, right= 0cm of mulb, minimum height=0.6cm] (mulb1) {}; 
		\node [draw, rectangle, right= 0cm of mulb1, minimum height=0.6cm] (mulb2) {};
		\node [draw, rectangle, right= 0cm of mulb2, minimum height=0.6cm] (mulb3) {};
		\node [draw, rectangle, right= 0cm of mulb3, minimum height=0.6cm] (mulb4) {};
		\draw [->] (inr) -- (mulr);
		\draw [->] (cr) -- (mulr);
		\draw [->] (ing) -- (mulg);
		\draw [->] (cg) -- (mulg);
		\draw [->] (inb) -- (mulb);
		\draw [->] (cb) -- (mulb);
		
		\node[draw, circle, below right= 1.25cm and 2cm of mulg3] (addgb) {$+$};
		\node [draw, rectangle, right= 0cm of addgb, minimum height=0.6cm] (addgb1) {}; 
		\node [draw, rectangle, right= 0cm of addgb1, minimum height=0.6cm] (addgb2) {};
		\node [draw, rectangle, right= 0cm of addgb2, minimum height=0.6cm] (addgb3) {};
		\draw [->] (mulb4) -- ++ (0.5cm,0) -- (addgb);
		\draw [->] (mulg4) -- ++ (0.5cm,0) -- (addgb);
		
		
		\node [draw, rectangle, above= 4.725cm of addgb1, minimum height=0.6cm] (mulr5) {}; 
		\node [draw, rectangle, right= 0cm of mulr5, minimum height=0.6cm] (mulr6) {};
		\node [draw, rectangle, right= 0cm of mulr6, minimum height=0.6cm] (mulr7) {};
		\draw [->] (mulr4) -- ++ (0.5cm,0) -- (mulr5);
		
		\node[draw, circle, below right= 2.5cm and 2cm of mulr5] (sum) {$+$};
		
		\draw [->] (mulr7) -- ++ (0.5cm,0) -- (sum);
		\draw [->] (addgb3) -- ++ (0.5cm,0) -- (sum);
		
		\node[right= of sum] (out) {$intensity$};
		\draw [->] (sum) -- (out);
	\end{tikzpicture}
  \caption{RGB to grayscale intensity freeruning conversion pipeline}
\end{figure}

\pagebreak

\subsection{Decoupling Processing Stages with Shift Registers}

Shift Registers with intelligent clock enables can be used as an queue that doesn't need counters like a FIFO. I decided to use this kind of decoupling to fulfill adder limitation. For a efficient FIFO implementation with high bandwidth single cycle counters are needed.

\paragraph{Proposed decoupling shift register}
My proposed shift register works in two modes stalled and non stalled. For each data word register there is also a valid register. During non stall cycles elements are inserted at first taken space in the shift register chain and all stored value staring at this place to end are shifted. As opposite during stall cycles elements are added in the first space and all registers until the first invalid registers are shifted forward. The proposed decoupling element preserves sorting because at every time elements are added before the first all ready stored element. During non stall cycles the amount of stored elements stay constant, but free spaces is moved to the front. The amount of elements that can be stored during a stall increases.

\subsection{SLC Implementation}
The SLC implementation is a straight forward conversion of the C version. Because the grayscale conversion can be implemented embarrassingly parallel (map) by assign a micro thread to each pixel to convert. The thread index is used to load the input pixel color and to store after the conversion the intensity value.

\section{Histogram}
The computation of a histogram can be seen as a map reduce operation. Map converts a intensity to a bin index and the reduction counts the occurrence of each index. The map operation is again embarrassingly parallel. 

\subsection{Fix Point}

The double precision value to bin map functions uses following equation: 

$f(x,b) = round(x*(b-1)/255.0)$

The rounding can be solved be using one bit more precision then needed, therefore the result would be fixed point number with single bit after the decimal point. This bit is one if decimal part is $0.5$ or larger. If this bit is one we easily add one to the integer part. Problematic is the division by $255_{10}=11111111_2$ this can not be implemented with a simple shift. It could be implemented by iterative shifting and subtraction. 

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=C]
static inline uint8_t maptobin(uint8_t p) {
	uint16_t bin = ((uint16_t)p) * (BINS-1);
	bin = (bin >> 8) + ((bin >> 7) & 1);
	return (uint8_t)bin;
}
\end{lstlisting}
\end{minipage}

\subsection{Error Evaluation}

We used in our fix point implementation division by 256 via a simple shift by 8. Because of this difference we assign some values to a lower bin. But for bin values $2^n+1 = {1,2,5,9,17,33,65,129}$ we get exactly the same result.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{histoerror}
	\caption{Mean Absolute Error over the 8 Bit value range.}
\end{figure}

\subsection{Datapath}

The datapath for the histogram computation is split in two parts. The map part converting intensity values to bins and the reduction part counting bin occurrence. 

\paragraph{Map}

For the map part i used the same approach as before for the grayscale conversion. A free running pipeline with consecutive shift register decoupler. The pipeline consists of a single multiplier following an adder implementing the rounding. Input for the multiplier is the fixed value $BIN-1$ and the current intensity pixel. Input for the adder is the result of the multiplier shift by 8 and the result shifted by 7 bitwise and 1. This is equivalent to the C implementation. 

\paragraph{Reduce}

\end{document}